-- Full updated script with moveTo fix and complete logic

if not game:IsLoaded() then
	game.Loaded:Wait()
end

function filter<T>(arr: { T }, func: (T) -> boolean): { T }
	local new_arr = {}
	for _, v in pairs(arr) do
		if func(v) then
			table.insert(new_arr, v)
		end
	end
	return new_arr
end

function map<T, U>(arr: { T }, func: (T) -> U): { U }
	local new_arr = {}
	for i, v in pairs(arr) do
		new_arr[i] = func(v)
	end
	return new_arr
end

--- Constants ---
local Players = game:GetService("Players")
local VIM = Instance.new("VirtualInputManager")
local PathfindingService = game:GetService("PathfindingService")
local TeleportService = game:GetService("TeleportService")

local Player = Players.LocalPlayer
local Gui = Player:WaitForChild("PlayerGui")
local Map = workspace:WaitForChild("Map")
local StreetSigns = Map.RoadNetwork.StreetSigns:GetChildren()
local Props = Map:WaitForChild("Props")
local ATMs = filter(Props:GetChildren(), function(v)
	local isATM = v.Name == "ATM"
	if isATM then
		print("Found ATM:", v:GetFullName())
	else
		print("Skipped non-ATM prop:", v:GetFullName())
	end
	return isATM
end)

local function notify(text: string, duration: number?)
	print(text)
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "AutoDrop",
		Text = text,
		Duration = duration or 3,
	})
end

local function keypress(key: Enum.KeyCode)
	VIM:SendKeyEvent(true, key, false, game)
	task.wait()
	VIM:SendKeyEvent(false, key, false, game)
	task.wait()
end

local function clickOnUi(element: TextButton)
	game:GetService("GuiService").SelectedObject = element
	task.wait()
	keypress(Enum.KeyCode.Return)
	task.wait()
	game:GetService("GuiService").SelectedObject = nil
	task.wait()
end

local function clickOnOffscreenUi(element: TextButton)
	task.spawn(function()
		firesignal(element.MouseButton1Click, 0, 0)
	end)
	task.wait()
end

local function isCombatLogging()
	return Gui.Hotbar.HotbarHolder.List.HotbarCombatLogging.Visible
end

local function Character()
	return Player.Character or Player.CharacterAdded:Wait()
end

local function Humanoid()
	return Character():WaitForChild("Humanoid")
end

local function HRP()
	return Character():WaitForChild("HumanoidRootPart")
end

local function closest(parts: { BasePart | Model }): BasePart
	local closest = nil
	local closest_distance = math.huge
	for _, part in pairs(parts) do
		local position = part:IsA("BasePart") and part.Position or part:GetPivot().Position
		local distance = (position - HRP().Position).Magnitude
		if distance < closest_distance then
			closest = part
			closest_distance = distance
		end
	end
	return closest
end

local function isAtmWorking(atm: Model)
	print("Checking ATM:", atm:GetFullName())
	local screen = atm:FindFirstChild("Screen", true)
	if not screen then
		warn("ATM does not have a 'Screen' descendant: " .. tostring(atm))
		return false
	end
	warn("ATM Screen found: " .. tostring(screen) .. ", Enabled = " .. tostring(screen.Enabled))
	if screen.Enabled then
		warn("ATM screen is visible; ATM is likely in use or broken.")
	else
		warn("ATM screen is hidden; ATM is ready.")
	end
	return screen and not screen.Enabled
end

local function moveTo(target: BasePart | Model | Vector3 | CFrame)
	for _, part in pairs(workspace:GetChildren()) do
		if part:IsA("Part") and part.Name == "Waypoint" then
			part:Destroy()
		end
	end

	local epsilon = 7
	local position
	local temp = {}

	if typeof(target) == "Vector3" then
		position = target
	elseif typeof(target) == "CFrame" then
		position = target.Position
	elseif target then
		if target:IsA("BasePart") then
			position = target.Position
		else
			position = target:GetPivot().Position
		end
		for _, v in pairs((target :: BasePart | Model):GetChildren()) do
			if v:IsA("BasePart") and v.CanCollide then
				table.insert(temp, v)
				v.CanCollide = false
			end
		end
	else
		warn("moveTo: target is nil")
		return
	end

	local path = PathfindingService:CreatePath({ AgentCanJump = false, AgentCanClimb = true, WaypointSpacing = 0.5 })

	local success, errorMessage = pcall(function()
		path:ComputeAsync(HRP().Position, position)
	end)

	for _, v in pairs(temp) do
		v.CanCollide = true
	end

	if success and path.Status == Enum.PathStatus.Success then
		for _, waypoint in ipairs(path:GetWaypoints()) do
			local p = Instance.new("Part", workspace)
			p.Position = waypoint.Position
			p.Name = "Waypoint"
			p.Anchored = true
			p.CanCollide = false
			p.Color = Color3.new(1, 0, 0)
			p.Size = Vector3.new(0.2, 0.2, 0.2)
		end
		for _, waypoint in ipairs(path:GetWaypoints()) do
			if (position - HRP().Position).Magnitude <= epsilon then
				break
			end
			VIM:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
			Humanoid():MoveTo(waypoint.Position)
			Humanoid().MoveToFinished:Wait()
		end
		VIM:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
	else
		notify("Path not computed " .. (errorMessage or "") .. tostring(path.Status))
	end
end

local function withdraw(amount: number?)
	local ATMWithdrawButton = Gui:FindFirstChild("ATMWithdrawButton", true)
	local ATMAmount = Gui:FindFirstChild("ATMActionAmount", true):FindFirstChild("Frame"):FindFirstChildOfClass("TextBox")
	local ATMConfirmButton
	for _, v in pairs(Gui:FindFirstChild("ATMActionAmount", true).Parent:GetChildren()) do
		if v:IsA("TextButton") and v.ZIndex == 1 then
			ATMConfirmButton = v
		end
	end
	clickOnOffscreenUi(ATMWithdrawButton)
	ATMAmount.Text = amount or 999999999
	clickOnOffscreenUi(ATMConfirmButton)
end

local function bank()
	for _, v in pairs(Gui:FindFirstChild("ATMWithdrawButton", true).Parent:GetChildren()) do
		if v:IsA("TextLabel") and v.Text:find("Bank") then
			return tonumber(v.Text:sub(16))
		end
	end
	error("Couldn't get money")
end

local function resetCharacter()
	keypress(Enum.KeyCode.Escape)
	task.wait(0.1)
	keypress(Enum.KeyCode.R)
	task.wait(0.1)
	keypress(Enum.KeyCode.Return)
	task.wait(1)
	TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, Player)
end

-- Game entry and ATM interaction logic
print("Waiting for loading screen")
while Gui:FindFirstChild("LoadingScreen", true) do
	task.wait()
end

print("Entering game")
if Gui:FindFirstChild("SplashScreenGui") then
	clickOnUi(Gui.SplashScreenGui.Frame.PlayButton)
	task.wait(3)
end

print("Skipping character creator")
if Gui:FindFirstChild("CharacterCreator") and Gui.CharacterCreator.Enabled then
	clickOnUi(Gui.CharacterCreator.MenuFrame.AvatarMenuSkipButton)
	task.wait(5)
end

print("Disabling door collision")
for _, v in pairs(workspace:GetDescendants()) do
	if v:IsA("Model") and v.Name == "DoorSystem" then
		for _, d in pairs(v:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CanCollide = false
			end
		end
	end
end

if Player.DisplayName == getgenv().TargetPlayer then return end

if bank() > getgenv().KeepAmount then
	notify("Moving to ATM")
	local filteredATMs = filter(ATMs, function(atm)
	print("Checking ATM for filter:", atm:GetFullName())
	local ok, result = pcall(isAtmWorking, atm)
	if not ok then
		warn("Error while checking ATM:", result)
	else
		print("ATM is working:", result)
	end
	return ok and result
end)
print("Total filtered working ATMs:", #filteredATMs)
local atm = closest(filteredATMs)
	if not atm then
		notify("No working ATM found")
		return
	end
	moveTo(atm)
	while not isAtmWorking(atm) do
		atm = closest(filter(ATMs, isAtmWorking))
		if not atm then
			notify("No working ATM found")
			return
		end
		moveTo(atm)
		task.wait()
	end
	for i = 1, 3 do
		notify("Withdrawing " .. i)
		withdraw(bank() - getgenv().KeepAmount)
		task.wait(0.1)
	end
end

notify("Moving to target location")
moveTo(getgenv().TargetLocation)

while not isCombatLogging() do
	task.wait()
end

if getgenv().ResetCharacter then
	resetCharacter()
else
	while not Gui.DeathScreen.DeathScreenHolder.Visible do
		task.wait()
	end
	task.wait(1)
	TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, Player)
end
